package TileMap;

import java.awt.Color;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;

import javax.imageio.ImageIO;
import Main.GamePanel;

public class TileSet {
	//tile dimension
	private int tileDim;
	private double x;
	private double y;
	
	//tiles to draw - slightly larger than screen width
	private int displayTilesAcross;
	private int displayTilesDown; 
	
	//map generated by file
	private int[][] map;
	
	//tileSet resource
	private BufferedImage tileSet;
	private ArrayList<Tile> tiles;
	
	//of map
	private int width;
	private int height;
	
	//limits on display position
	private int xmin;
	private int xmax;
	private int ymin;
	private int ymax;
	
	//map resource
	private BufferedReader mapFile;
	private int mapTilesAcross;
	private int mapTilesDown;
	
	private int startXDisplay;
	private int startYDisplay;

	public TileSet(String s, int dim, int type) {
		this.tileDim = dim;
		//1 is blocked, 0 is not, 2 is ladder
		displayTilesAcross = (GamePanel.WIDTH / dim) + 2; //displays tiles to fill screen plus buffer of two
		displayTilesDown = (GamePanel.HEIGHT / dim) + 2; //displays tiles to fill screen plus buffer of two
		
		startXDisplay = -dim; //starting display location is negative dimension (off screen by one tile
		startYDisplay = -dim;
				
		try {
			tileSet = ImageIO.read(getClass().getResourceAsStream(s));
			
			//calculate tiles in image (x and y)
			tiles = new ArrayList<Tile>();
			
			//load tiles into arrayList as subimages of tileset
			for (int row = 0; row < tileSet.getHeight(); row += dim) {
				for (int col = 0; col < tileSet.getWidth(); col += dim) {
					
					//add each subimage of the tileset to the arraylist of tiles
					if (row == 0 && col == 0) {
						//type zero, air
						tiles.add(new Tile(tileSet.getSubimage(col, row, dim, dim), 0));
					}
					else if ((row == 2 * dim && col == 2 * dim) || (row == 2 * dim && col == 3 * dim)) {
						//these are the locations of ladders
						tiles.add(new Tile(tileSet.getSubimage(col, row, dim, dim), 2));
					}
					else {
						tiles.add(new Tile(tileSet.getSubimage(col, row, dim, dim), type));
					}
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		
	}
	public void loadMap(String s) {
		String[] strArray;
		String input; //line read from file
		
		
		try {
			//try reading from map file
			InputStream in = getClass().getResourceAsStream(s);
			mapFile = new BufferedReader(new InputStreamReader(in));

			mapTilesAcross = Integer.parseInt(mapFile.readLine()); //line one is map x
			mapTilesDown = Integer.parseInt(mapFile.readLine()); //line two is map y
			
			width = mapTilesAcross * this.tileDim;
			height = mapTilesDown * this.tileDim;
			
			//limits on position
			xmin = GamePanel.WIDTH - width; //(negative if map width is greater than 320)
			xmax = 0;	//max x set
			ymin = GamePanel.HEIGHT - height; //(negative if map height is greater than 240)
			ymax = 0;	//max y set
			
			//build map according to size
			map = new int[mapTilesAcross][mapTilesDown];
			
			for (int y = 0; y < mapTilesDown; y++) {
				//for each line of mapfile, read line, split by commas, then use ints for line to find a tile in set
				input = mapFile.readLine();
				strArray = input.split(",");
				
				for(int x = 0; x < mapTilesAcross; x++) {
					//parse current value and find image in tileset to load into map 2d array
					
				    map[x][y] = Integer.parseInt(strArray[x]);
					
				}
			}
		} catch (Exception e) {
			e.printStackTrace();
		}

	}
	public void draw(Graphics2D g) {

		for (int x = this.startXDisplay; x < this.startXDisplay + displayTilesAcross; x++) {
			
			if(x >= mapTilesAcross) break;
			if(x < 0) break;
			
			for (int y = this.startYDisplay; y < this.startYDisplay + displayTilesDown; y++) {
			
				if(y >= mapTilesDown) break;
				if(y < 0) break;
				
				if(map[x][y] == 0) continue;
				
				int rc = map[x][y];
				
				
				g.drawImage(tiles.get(rc).getImage(),(int) this.x + x * this.tileDim,(int) this.y +y * this.tileDim, null);
				
				//draw types if necessary
				//g.drawString("" + tiles.get(rc).getType(), (int) this.x + x * this.tileDim,(int) this.y +y * this.tileDim);

			}
		}

	}
	public void setPosition(double x, double y) {
		
		//position change
		this.x += x - this.x;
		this.y += y - this.y;
	
		fixBounds();
		
		//get tile location for start of display
		this.startXDisplay = (int)-this.x / this.tileDim;
		this.startYDisplay = (int)-this.y / this.tileDim;
		
	}
	
	private void fixBounds() {
		if(x < xmin) x = xmin;
		if(y < ymin) y = ymin;
		if(x > xmax) x = xmax;
		if(y > ymax) y = ymax;
	}
	public int getSize() {
		return this.tileDim;
	}
	public int getType(int row, int col) {
		int rc = map[row][col];
		return tiles.get(rc).getType();
	}
	public int getx() { return (int)x; }
	public int gety() { return (int)y; }
	public int getWidth() { return mapTilesAcross; }
	public int getHeight() { return mapTilesDown; }


}
